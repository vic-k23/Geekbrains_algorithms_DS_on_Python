# 1. Проанализировать скорость и сложность одного любого алгоритма из разработанных в рамках домашнего задания первых
# трех уроков.
# Примечание. Идеальным решением будет:
# a. выбрать хорошую задачу, которую имеет смысл оценивать,
# b. написать 3 варианта кода (один у вас уже есть),
# c. проанализировать 3 варианта и выбрать оптимальный,
# d. результаты анализа вставить в виде комментариев в файл с кодом (не забудьте указать, для каких N вы проводили
# замеры),
# e. написать общий вывод: какой из трёх вариантов лучше и почему.


"""
Возьмём задачу №1 из 3-го урока.
1. В диапазоне натуральных чисел от 2 до 99 определить, сколько из них кратны каждому из чисел в диапазоне от 2 до 9.
"""

rb = 5000

# Version 1
# Время выполнения 1000 запусков: 0.048839200000000006 0.0497022 0.051172600000000006
# Время выполнения 1000 запусков для списка от 2 до 5000: 4.1229273 3.4549887 3.4941119
# cProfile: было вызвано 4 функции


def count_divisible1():
    result = [0] * 8
    for dev in range(2, 10):
        for digit in range(2, rb):
            if digit % dev == 0:
                result[dev - 2] += 1

    return result


# print(count_divisible1())

# Version 2
# Время выполнения 1000 запусков: 0.07804920000000001 0.0739841 0.0935433
# Время выполнения 1000 запусков для списка от 2 до 5000: 4.9126739 4.791168899999999 4.895183000000001
# cProfile: было вызвано 4 функции


def count_divisible2():
    result = [0] * 8
    for digit in range(2, rb):
        for dev in range(2, 10):
            if digit % dev == 0:
                result[dev - 2] += 1

    return result


# print(count_divisible2())


# Version 3
# Время выполнения 1000 запусков: 0.06236089999999999 0.040965 0.0453754
# Время выполнения 1000 запусков для списка от 2 до 5000: 2.3969603999999993 2.576169199999999 2.6452545
# cProfile: была вызвана 21 функция


def count_divisible3():
    spam = [[dgt for dgt in range(2, rb) if dgt % div == 0] for div in range(2, 10)]
    res = []
    for row in spam:
        res.append(len(row))

    return res


# print(count_divisible3())

if __name__ == '__main__':

    import timeit
    import cProfile

    print(timeit.timeit("count_divisible1()", setup="from __main__ import count_divisible1", number=1000))
    print(timeit.timeit("count_divisible2()", setup="from __main__ import count_divisible2", number=1000))
    print(timeit.timeit("count_divisible3()", setup="from __main__ import count_divisible3", number=1000))
    #
    # cProfile.run('count_divisible1()')
    # cProfile.run('count_divisible2()')
    # cProfile.run('count_divisible3()')

    """
    Вывод: Время выполнения примерно одинаковое при маленьких размерах массива, но при достаточно большом размере
    становится очевидным преимущество варианта 3. Из результатов можно сделать предположение, что: 
    1) алгоритм с генератором списка работает эффективнее, чем циклы 1-го и 2-го вариантов; 
    2) получилось, что перебрать большее количество элементов меньшее количество раз быстрее, чем перебрать меньшее
        количество элементов большее количество раз, то есть лучше пробежаться несколько раз по длинному списку, чем
        большое количество раз пробегаться по маленькому списку;
    3) инструмент cProfile малоэффективен в выбранной задаче.
    4) сложность всех алгоритмов, скорее всего, О(n), так как при увеличении количества вычислений, время выполнения
        увеличивается пропорционально.
    """
